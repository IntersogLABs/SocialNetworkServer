var ObjectId=require('mongodb').ObjectId
var async = require('async');
var bcrypt = require('bcryptjs');
module.exports = function(app){

    app.get('/me',function(req,res){
        res.send(req.currentUser);
    })

    app.get('/user', function (req, res) {
        DB.collection('users').find({}).toArray(function(err,data){
            res.send(data.map(function(user){
                delete user.pwd;
                return user;
            }));
        })
    })

    app.get('/user/:id',function(req,res){
        DB.collection('users').findOne({_id: new ObjectId(req.params.id)}, function(err, user) {
            if(!user){
                res.status(404).send({message:"not found"})
                return;
            }
            delete user.pwd;
            user.currentUser=(String(req.currentUser._id)==String(user._id))? false:true;
            user.follow=req.currentUser.following.indexOf(String(user._id))==-1;
            console.log(user.currentUser);
            console.log(user.follow);
            res.send(user);
        })
    })

    app.get('/me/wall', function(req,res) {
        console.log(req.params);
        var usersCollection=DB.collection('users');
        DB.collection('posts').find({"ownerId._id": String(req.currentUser._id)}).toArray(function(err, posts){
            async.mapLimit(posts,5,function(post, next){
                usersCollection.findOne({_id: new ObjectId(post.ownerId._id)}, function(err, data) {
                    delete data.pwd;
                    delete data.follow;
                    post.owner=data;
                })
                usersCollection.findOne({_id:new ObjectId(post.authorId._id)}, function(err, data) {
                    delete data.pwd;
                    delete data.follow;
                    post.author=data;
                    next(null, post);
                })
            }, function(err, data) {
                var len=data.length;
                for(var i=0;i<len;i++) {
                    data[i].Edit = String(data[i].author._id)==String(req.currentUser._id);
                }
                for(var i=0;i<len/2;i++) {
                    var temp=data[i];
                    data[i]=data[len-i-1];
                    data[len-i-1]=temp;
                }                
                res.send(data);
            })
        })
    })

    app.get('/users/:id/wall', function(req,res) {
        var usersCollection=DB.collection('users');
        DB.collection('posts').find({"ownerId._id": req.params.id}).toArray(function(err, posts){
            async.mapLimit(posts,5,function(post, next){
                usersCollection.findOne({_id: new ObjectId(post.ownerId._id)}, function(err, data) {
                    delete data.pwd;
                    post.owner=data;
                })
                usersCollection.findOne({_id:new ObjectId(post.authorId._id)}, function(err, data) {
                    delete data.pwd;
                    post.author=data;
                    next(null, post);
                })
            }, function(err, data) {
                var len=data.length;
                for(var i=0;i<len;i++) {
                    data[i].Edit = String(data[i].author._id)==String(req.currentUser._id) 
                }
                for(var i=0;i<len/2;i++) {
                    var temp=data[i];
                    data[i]=data[len-i-1];
                    data[len-i-1]=temp;
                }   
                res.send(data);
            })
        })
    })    

    app.post('/register', function (req, res) {
        //проверить свободен ли ник и имейл
        if (!req.body.nick) {
            res.status(406).send({message: "Nick is required"})
            return;
        } else if (!req.body.pwd) {
            res.status(406).send({message: "Password is required"})
            return;
        } else if (req.body.pwd != req.body.repeatPwd) {
            res.status(406).send({message: "Passwords do not match"})
            return;
        } else if (!req.body.email) {
            res.status(406).send({message: "Email is required"})
            return;
        } 
        console.log(bcrypt);
        var user = {
            email: req.body.email,
            nick: req.body.nick,
            pwd: bcrypt.hashSync(req.body.pwd,10),
            following: []
        };
        var fNick=false, fEmail=false;
        DB.collection("users").find({}).toArray(function(err, users) {
            async.mapLimit(users,5,function(user, next){
                if(user.nick==req.body.nick) fNick=true;
                if(user.email==req.body.email) fEmail=true;
                next();
            },function(err) {
                if(fNick) {
                    res.status(406).send({message: "Nick is already used"})
                    return;
                }
                if(fEmail) {
                    res.status(406).send({message: "Email is already used"})
                    return;
                }
                DB.collection('users').insert(user, function(err, data) { 
                    console.log(data.ops[0]);
                    req.cuurentUser=data.ops[0];          
                    delete data.pwd;
                    res.send(data);
                })
            })
        })
    })

    app.put('/me', function (req, res) {
        var user = req.currentUser;
        if (!req.body.nick) {
            res.status(400).send({message: "Nick is required"})
            console.log("Nick is required");
            return;
        } else if (!req.body.pwd) {
            res.status(400).send({message: "Password is required"})
            console.log("Password is required");
            return;
        } else if (req.body.pwd != req.body.repeatPwd) {
            res.status(400).send({message: "Passwords do not match"})
            console.log("Passwords do not match");
            return;
        } else if (!req.body.email) {
            res.status(400).send({message: "Email is required"})
            console.log("Email is required");
            return;
        } 
        var fNick=false, fEmail=false;
        DB.collection("users").find({}).toArray(function(err, users) {
            async.mapLimit(users,5,function(user1, next){
                if(user1.nick==req.body.nick && req.body.nick!= user.nick) fNick=true;
                if(user1.email==req.body.email && req.body.email!= user.email) fEmail=true;
                next();
            },function(err) {
                if(fNick) {
                    res.status(400).send({message: "Nick is already used"})
                    return;
                }
                if(fEmail) {
                    res.status(400).send({message: "Email is already used"})
                    return;
                }
                user.email = req.body.email;
                user.nick = req.body.nick;
                user.pwd = bcrypt.hashSync(req.body.pwd, 10);
                DB.collection('users').update({_id: new ObjectId(user._id)},user);
                res.send(user);                
            })  
        })      
    })

    app.delete('/me', function (req,res) {
        DB.collection('users').remove({"_id":req.currentUser._id});
        req.currentUser=null;
        res.send("Deleted");
    })

    app.get('/user/:id/following',function(req,res){
        var result=[];
        DB.collection('users').findOne({_id: new ObjectId(req.params.id)}, function (err, user) {
            if(!user) {
                res.status(404).send({message:"Can't find such user"})
                return;
            }
            async.each(user.following, function(item, next) {
                DB.collection('users').findOne({_id: new ObjectId(item)}, function (err, user1) {
                    delete user1.pwd;
                    delete user1.following;
                    result.push(user1);
                    next();
                })
                }, function (err) {
                    res.send(result);
            })
        })
    })

    app.get('/me/following',function(req,res){
        var result=[];
        console.log(req.currentUser._id);
        DB.collection('users').findOne({_id: new ObjectId(req.currentUser._id)}, function (err, user){
            if(!user) {
                res.status(404).send({message:"Can't find such user"})
                return;
            }
            async.each(user.following, function(item, next) {
                DB.collection('users').findOne({_id: new ObjectId(item)}, function (err, user1) {
                    delete user1.pwd;
                    delete user1.following;
                    result.push(user1);
                    next();
                })
                }, function (err) {
                    console.log(result);
                    res.send(result);
            })
        })
    })

    app.post('/user/:id/follow',function (req,res){
        var user = req.currentUser;
        if(_.contains((user.following), req.params.id) || user._id == req.params.id) {
            res.status(400).send({message: "You can't follow this person"})
            return;
        }
        user.following.push(req.params.id);
        DB.collection('users').update({_id: new ObjectId(user._id)}, {$set:{following: user.following}});
        res.send(user.following);
    })

    app.delete('/user/:id/follow', function (req,res) {
        var user = req.currentUser;
        var index=user.following.indexOf(req.params.id);
        if(index===-1) {
            res.status(400).send({message: "You don't follow this person"});
            return;
        }
        user.following.splice(index,1);
        DB.collection('users').update({_id: new ObjectId(user._id)}, {$set:{following: user.following}});
        res.send(user.following);
    })

    app.delete('/user/:id/follower', function (req,res) {
        DB.collection('users').findOne({_id: new ObjectId(req.params.id)}, 
        function (err, user) {
            var index=user.following.indexOf(String(req.currentUser._id));
            if(index===-1) {
                res.status(400).send({message: "This user doesn't follow you"});
                return;
            }
            user.following.splice(index,1);
            DB.collection('users').update({_id: new ObjectId(user._id)}, {$set:{following: user.following}});
            res.send(user.following);
        })
    })    

    app.get('/user/:id/followers', function (req,res) {
        DB.collection('users').find({following: req.params.id}).toArray(function(err, users) {
            res.send(users.map(function(user) {
                delete user.pwd;
                delete user.following;
                return user;
            }));
        })
    })

    app.get('/me/followers', function (req,res) {
        DB.collection('users').find({following: String(req.currentUser._id)}).toArray(function(err, users) {
            res.send(users.map(function(user) {
                delete user.pwd;
                delete user.following;
                return user;
            }));
        })
    })    
}